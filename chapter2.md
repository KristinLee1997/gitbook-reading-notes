# Chapter2

## 第8条 覆盖equals\(\)时请遵守通用约定

**只要满足一下任意一个条件,类的每个实例都只与自身相等**:

1. 类的每个实例本质上都是唯一的.
2. 不关心类是否提供了"逻辑相等"的测试功能
3. 超类已经覆盖了equals,从超类继承过来的行为对于子类也是合适的
4. 类是私有的或是包级私有的,可以确定它的equals方法永远不会被调用 

**equals方法的等价关系**:

1. 自反性:对于任何非null的引用值x,x.equals\(x\)必须返回true
2. 对称性:对于任何非null的引用值x和y,当且仅当y.equals\(x\)返回true时,x.equals\(y\)必须返回true
3. 传递性:对于任何非null的引用值x,y和z,如果x.equals\(y\)返回true,并且y.equals\(z\)也返回true,那么x.equals\(z\)也必须返回true
4. 一致性:对于任何非null的引用值x和y,只要equals的比较操作在对象中所用的信息没有被修改,多次调用x.equals\(y\)就会一致地返回true,或者一致地返回false
5. 对于任何非null的引用值,x.equals\(null\)必须返回false. 

**实现高质量equals方法的诀窍**:

1. 使用==操作符检查"参数是否为这个对象的引用"
2. 使用instanceof操作符检查"参数是否为正确的类型"
3. 把参数转换成正确的类型
4. 对于该类型中的每个"关键"域,检查参数中的域是否与该对象中的对应的域相匹配
5. 当编写完成了equals方法之后,应该问自己三个问题:它是否是对称的,传递的,一致

   的

**注意**:

* 覆盖equals时总要覆盖hashCode
* 不要企图让equals方法过于智能
* 不要将equals声明中的Object对象替换为其他的类型

